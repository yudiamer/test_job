#!/usr/bin/env python3
"""
Trade Trends Dashboard Automation - Final Version
================================================
This script provides comprehensive automation for capturing Trade Trends 
dashboard from XFlush monitoring system with multiple capture options.

Features:
- Auto login to Dana authentication system
- Language switching from Chinese to English  
- Navigation to Trade Trends dashboard
- Choice between chart-only or full interface capture
- Error handling and fallback mechanisms

Usage:
    python3 trade_trends_final.py [--chart-only] [--headless]
    
    --chart-only: Capture only the chart (default: full interface)
    --headless: Run browser in background (default: visible)

Author: Generated by GitHub Copilot  
Date: October 24, 2025
"""

import time
import argparse
import os
import sys
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException, NoSuchElementException

# Add credentials directory to Python path
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
credentials_dir = os.path.join(project_root, "credentials")
sys.path.insert(0, credentials_dir)

from credentials_loader import get_xflush_credentials

class TradeTrendsAutomation:
    def __init__(self, headless=False, credentials=None):
        self.driver = None
        self.headless = headless
        
        # Load XFlush credentials from file
        if credentials is None:
            credentials = get_xflush_credentials()
        
        self.username = credentials['username']
        self.password = credentials['password']
        self.login_url = credentials['login_url']
        self.trade_trends_url = credentials['trade_trends_url']
        self.window_size = credentials['browser_window_size']
        self.wait_timeout = credentials['browser_wait_timeout']
        self.screenshot_wait = credentials['screenshot_wait_time']
        
    def setup_driver(self):
        """Setup Chrome driver with optimized settings"""
        from selenium.webdriver.chrome.options import Options
        chrome_options = Options()
        chrome_options.add_argument(f'--window-size={self.window_size}')
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-gpu')
        chrome_options.add_argument('--disable-blink-features=AutomationControlled')
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        if self.headless:
            chrome_options.add_argument('--headless')
            print("ğŸš€ Starting Chrome browser (headless mode)...")
        else:
            print("ğŸš€ Starting Chrome browser (visible mode)...")
        self.driver = webdriver.Chrome(options=chrome_options)
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        
    def login_and_setup(self):
        """Complete login and language setup process"""
        # Navigate to login page
        print("ğŸŒ Navigating to login page...")
        self.driver.get(self.login_url)
        #time.sleep(3)
        
        # Login with credentials
        print("ğŸ” Logging in...")
        username_field = self.driver.find_element(By.CSS_SELECTOR, "input[type='text']")
        password_field = self.driver.find_element(By.NAME, "password")
        login_button = self.driver.find_element(By.XPATH, "//span[contains(text(), 'ç™»å½•')]/parent::button")
        
        username_field.send_keys(self.username)
        password_field.send_keys(self.password)
        login_button.click()
        
        # Wait for dashboard to load
        print("â³ Waiting for dashboard to load...")
        #time.sleep(self.wait_timeout)
        
        # Change language to English
        print("ğŸŒ Changing language to English...")
        try:
            location_icons = self.driver.find_elements(By.CSS_SELECTOR, "i.anticon.anticon-environment-o")
            if location_icons:
                location_icons[0].click()
                #time.sleep(2)
                
                english_elements = self.driver.find_elements(By.XPATH, "//a[contains(text(), 'English')]")
                if english_elements:
                    english_elements[0].click()
                    #time.sleep(3)
                    print("âœ… Language changed to English")
                else:
                    print("âš ï¸  English option not found, continuing...")
            else:
                print("âš ï¸  Location icon not found, continuing...")
        except Exception as e:
            print(f"âš ï¸  Language change had issues: {e}, continuing...")
        
        # Navigate to Trade Trends dashboard
        print(f"ğŸ¯ Navigating to Trade Trends dashboard...")
        self.driver.get(self.trade_trends_url)
        #time.sleep(3)
        
        print(f"ğŸ“ Current URL: {self.driver.current_url}")
        print(f"ğŸ“„ Page Title: {self.driver.title}")
        
        return True
    
    def click_trade_trends(self):
        """Find and click on Trade Trends element"""
        print("ğŸ” Looking for Trade Trends...")
        
        trade_trends_selectors = [
            "//span[contains(text(), 'Trade Trends')]",
            "//div[contains(text(), 'Trade Trends')]",
            "//*[contains(text(), 'Trade Trends')]",
        ]
        
        for selector in trade_trends_selectors:
            try:
                print(f"ğŸ” Trying selector: {selector}")
                elements = self.driver.find_elements(By.XPATH, selector)
                
                for element in elements:
                    if element.is_displayed() and element.is_enabled():
                        element_text = element.text.strip()
                        print(f"âœ… Found element: '{element_text}'")
                        
                        if 'trade trends' in element_text.lower():
                            print(f"ğŸ¯ Clicking on Trade Trends: '{element_text}'")
                            
                            # Scroll to element and click
                            self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
                            time.sleep(1)
                            element.click()
                            time.sleep(3)
                            
                            print("âœ… Clicked Trade Trends successfully!")
                            return True
                            
            except Exception as e:
                print(f"âŒ Error with selector {selector}: {e}")
                continue
        
        print("âŒ Trade Trends not found")
        return False
    
    def capture_chart_only(self):
        """Capture only the Trade Trends chart"""
        print("ğŸ“¸ Capturing Trade Trends chart only...")
        
        #time.sleep(3)  # Wait for chart to load
        
        # Find the chart container
        try:
            chart_element = self.driver.find_element(By.XPATH, "//div[@class='jr xf-chart' and @chart-title='Trade Trends']")
            
            # Generate filename
            timestamp = int(time.time())
            filename = f"trade_trends_chart_{timestamp}.png"
            # Use absolute path to screenshots directory
            project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            filepath = os.path.join(project_root, "screenshots", filename)
            
            # Scroll to element and capture
            self.driver.execute_script("arguments[0].scrollIntoView(true);", chart_element)
            #time.sleep(2)
            chart_element.screenshot(filepath)
            
            print(f"âœ… Chart captured: {filename}")
            print(f"ğŸ“ Captured area: {chart_element.size['width']}x{chart_element.size['height']}")
            
            return filepath
            
        except Exception as e:
            print(f"âŒ Chart capture failed: {e}")
            return None
    
    def capture_statistics_info(self):
        """Capture the Statistics Info table specifically"""
        print("ğŸ“Š Looking for Statistics Info icon to click...")
        
        try:
            # Wait a bit for the interface to load completely
            #time.sleep(self.screenshot_wait)
            
            # First, try to click the Statistics Info icon to open the popup
            statistics_icon_clicked = False
            
            # Try different selectors for the statistics icon including parent elements
            # Try different selectors for the statistics icon - start with specific path
            icon_selectors = [
                # User provided specific XPath - try this first
                "(//div[@class='jr xf-chart']//i[contains(@class, 'xf-cms-icon-sangang')])[1]",
                # Specific path provided by user
                "/html/body/div[7]/div[2]/div[2]/div/div/h3/i",
                "//div[7]/div[2]/div[2]/div/div/h3/i",
                "//h3/i[@class='xf-cms-iconfont xf-cms-icon-sangang']",
                "//h3//i[contains(@class, 'xf-cms-icon-sangang')]",
                
                # General selectors as backup
                "//i[@class='xf-cms-iconfont xf-cms-icon-sangang']",
                "//i[contains(@class, 'xf-cms-icon-sangang')]",
                
                # Try looking for it in specific parent containers
                "//div[contains(@class, 'chart')]//i[contains(@class, 'sangang')]",
                "//div[contains(@class, 'toolbar')]//i[contains(@class, 'sangang')]", 
                "//div[contains(@class, 'header')]//i[contains(@class, 'sangang')]",
                "//div[contains(@class, 'controls')]//i[contains(@class, 'sangang')]",
                
                # Try looking in button or clickable containers
                "//button//i[contains(@class, 'sangang')]",
                "//a//i[contains(@class, 'sangang')]",
                "//span//i[contains(@class, 'sangang')]",
                
                # Try with different combinations
                "//*[contains(@class, 'xf-cms-icon-sangang')]",
                "//i[contains(@class, 'sangang')]",
                
                # Look for it near chart elements
                "//div[contains(@class, 'xf-chart')]//i[contains(@class, 'sangang')]",
                "//div[contains(@class, 'line-chart')]//i[contains(@class, 'sangang')]"
            ]
            
            for selector in icon_selectors:
                try:
                    print(f"ğŸ” Trying icon selector: {selector}")
                    icon_elements = self.driver.find_elements(By.XPATH, selector)
                    
                    print(f"   Found {len(icon_elements)} elements with this selector")
                    
                    for i, icon in enumerate(icon_elements):
                        if icon.is_displayed():
                            # Get parent element info for debugging
                            try:
                                parent = icon.find_element(By.XPATH, "..")
                                parent_class = parent.get_attribute("class")
                                parent_tag = parent.tag_name
                                print(f"   Icon {i+1}: Parent = <{parent_tag} class='{parent_class}'>")
                            except:
                                print(f"   Icon {i+1}: Could not get parent info")
                            
                            # Try to click this icon
                            try:
                                print(f"   Trying to click icon {i+1}...")
                                
                                # Scroll to element
                                self.driver.execute_script("arguments[0].scrollIntoView({behavior: 'smooth', block: 'center'});", icon)
                                #time.sleep(2)
                                
                                # Try different click methods
                                click_success = False
                                
                                # Method 1: Direct click
                                try:
                                    icon.click()
                                    print(f"   âœ… Direct click succeeded on icon {i+1}")
                                    click_success = True
                                except Exception as e:
                                    print(f"   âŒ Direct click failed: {e}")
                                
                                # Method 2: JavaScript click
                                if not click_success:
                                    try:
                                        self.driver.execute_script("arguments[0].click();", icon)
                                        print(f"   âœ… JavaScript click succeeded on icon {i+1}")
                                        click_success = True
                                    except Exception as e:
                                        print(f"   âŒ JavaScript click failed: {e}")
                                
                                # Method 3: Click parent element
                                if not click_success:
                                    try:
                                        parent = icon.find_element(By.XPATH, "..")
                                        parent.click()
                                        print(f"   âœ… Parent click succeeded on icon {i+1}")
                                        click_success = True
                                    except Exception as e:
                                        print(f"   âŒ Parent click failed: {e}")
                                
                                if click_success:
                                    statistics_icon_clicked = True
                                    
                                    # Wait for popup to appear
                                    print("â³ Waiting 8 seconds for statistics popup to appear...")
                                    #time.sleep(3)
                                    
                                    # Check if popup appeared by looking for the table
                                    popup_check = self.driver.find_elements(By.XPATH, "//div[contains(@class, 'xf-line-chart-stat-wrapper')]")
                                    if popup_check and popup_check[0].is_displayed():
                                        print(f"âœ… Statistics popup appeared after clicking icon {i+1}!")
                                        break
                                    else:
                                        print(f"âŒ No popup appeared after clicking icon {i+1}, trying next...")
                                        statistics_icon_clicked = False
                                        continue
                                        
                            except Exception as e:
                                print(f"   âŒ Failed to click icon {i+1}: {e}")
                                continue
                    
                    if statistics_icon_clicked:
                        break
                        
                except Exception as e:
                    print(f"âš ï¸ Selector failed: {e}")
                    continue
            
            # If no icon was clicked successfully, return None
            if not statistics_icon_clicked:
                print("âŒ Could not click any statistics icon!")
                return None
            
            # Now try to find the statistics popup that should have appeared
            print("ğŸ” Looking for Statistics Info popup...")
            
            # Try different selectors to find the statistics popup
            statistics_selectors = [
                "//div[contains(@class, 'xf-line-chart-stat-wrapper')]",
                "//div[contains(@class, 'stat-wrapper')]",
                "//div[contains(text(), 'Statistics Info')]",
                "//h3[contains(text(), 'Statistics Info')]", 
                "//span[contains(text(), 'Statistics Info')]",
                "//*[contains(text(), 'Statistics Info')]",
                "//table[contains(@class, 'xf-table')]",
                "//div[contains(@class, 'xf-pop-up')]//table",
                "//div[@class='table-responsive']//table",
                "//div[contains(@class, 'statistics')]//table",
            ]
            
            statistics_element = None
            
            for selector in statistics_selectors:
                try:
                    print(f"ğŸ” Trying statistics selector: {selector}")
                    elements = self.driver.find_elements(By.XPATH, selector)
                    
                    for element in elements:
                        if element.is_displayed():
                            element_text = element.text.strip()
                            print(f"âœ… Found element with text: '{element_text[:100]}...'")
                            
                            # Check if this looks like statistics info
                            if any(keyword in element_text.lower() for keyword in 
                                  ['statistics', 'column', 'max', 'min', 'average', 'total', 'count',
                                   'create order', 'payment apply', 'cashier consult', 'trade success']):
                                print(f"ğŸ¯ Found Statistics Info element!")
                                statistics_element = element
                                break
                                
                    if statistics_element:
                        break
                        
                except Exception as e:
                    print(f"âš ï¸ Selector {selector} failed: {e}")
                    continue

            if not statistics_element:
                print("âŒ Statistics Info section not found, trying to find any table...")
                # Fallback: look for any table
                try:
                    tables = self.driver.find_elements(By.TAG_NAME, "table")
                    for table in tables:
                        if table.is_displayed() and table.size['height'] > 100:
                            statistics_element = table
                            print("âœ… Found table element as fallback")
                            break
                except Exception as e:
                    print(f"âŒ Table fallback failed: {e}")

            if statistics_element:
                # Extract and parse statistics data first
                try:
                    print("ğŸ“Š Extracting statistics data...")
                    statistics_text = statistics_element.text
                    print(f"ğŸ“ Raw statistics text:\n{statistics_text}")
                    
                    # Parse the statistics data and calculate TPS
                    tps_data = self.extract_statistics_and_calculate_tps(statistics_text)
                    if tps_data:
                        print("ğŸ“ˆ TPS Calculation Results:")
                        for item in tps_data:
                            print(f"   ğŸ“Š {item['metric']}: Max={item['max']}, TPS={item['tps']:.2f}")
                        
                        # Save TPS data to file
                        self.save_tps_data(tps_data)
                    else:
                        print("âš ï¸ No TPS data could be extracted")
                except Exception as e:
                    print(f"âš ï¸ Data extraction failed: {e}")
                
                # Scroll to the element to ensure it's visible
                self.driver.execute_script("arguments[0].scrollIntoView(true);", statistics_element)
                #time.sleep(2)

                # Generate filename for statistics screenshot
                timestamp = int(time.time())
                filename = f"statistics_info_{timestamp}.png"
                project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                filepath = os.path.join(project_root, "screenshots", filename)

                # Take screenshot of the statistics element
                statistics_element.screenshot(filepath)

                print(f"âœ… Statistics Info captured: {filename}")
                print(f"ğŸ“ Captured area: {statistics_element.size['width']}x{statistics_element.size['height']}")

                return filepath
            else:
                print("âŒ Could not find Statistics Info section")
                return None

        except Exception as e:
            print(f"âŒ Statistics Info capture failed: {e}")
            return None
            
            print("ğŸ¯ Statistics icon clicked, now looking for the popup...")
            
            # Take a debug screenshot to see current page state
            timestamp_debug = int(time.time())
            debug_filename = f"debug_page_state_{timestamp_debug}.png"
            project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            debug_filepath = os.path.join(project_root, "screenshots", debug_filename)
            self.driver.save_screenshot(debug_filepath)
            print(f"ğŸ› Debug screenshot saved: {debug_filename}")
            
            # Also try to get page source to see what's actually there
            page_source = self.driver.page_source
            if 'statistics info' in page_source.lower() or 'stat-title' in page_source.lower():
                print("âœ… Statistics content found in page source")
            else:
                print("âš ï¸ No statistics content found in page source")
            
            # Now look for the Statistics Info popup that should have appeared
            popup_selectors = [
                "//div[@class='xf-line-chart-stat-wrapper xf-pop-up ng-scope']",
                "//div[contains(@class, 'xf-line-chart-stat-wrapper')]",
                "//div[contains(@class, 'xf-pop-up')]//span[contains(text(), 'Statistics Info')]",
                "//div[contains(@class, 'stat-heading')]//span[contains(text(), 'Statistics Info')]",
                "//div[@class='stat-heading']//span[@class='stat-title ng-binding']",
                "//table[@class='xf-table table table-condensed table-bordered table-striped table-hover']"
            ]
            
            statistics_element = None
            
            for selector in popup_selectors:
                try:
                    print(f"ğŸ” Trying popup selector: {selector}")
                    elements = self.driver.find_elements(By.XPATH, selector)
                    
                    for element in elements:
                        if element.is_displayed():
                            element_text = element.text.strip()
                            print(f"âœ… Found popup element with text: '{element_text[:100]}...'")
                            
                            # Check if this looks like statistics info
                            if any(keyword in element_text.lower() for keyword in 
                                  ['statistics info', 'column', 'max', 'min', 'average', 'total', 'count',
                                   'create order', 'payment apply', 'cashier consult', 'trade success']):
                                print(f"ğŸ¯ Found Statistics Info popup!")
                                
                                # If we found the table, try to get its parent container for better capture
                                if element.tag_name == 'table':
                                    try:
                                        # Try to get the parent popup container
                                        parent_popup = element.find_element(By.XPATH, "./ancestor::div[contains(@class, 'xf-line-chart-stat-wrapper')]")
                                        statistics_element = parent_popup
                                        print("âœ… Found parent popup container")
                                    except:
                                        statistics_element = element
                                        print("âœ… Using table element directly")
                                else:
                                    statistics_element = element
                                    
                                break
                                
                    if statistics_element:
                        break
                        
                except Exception as e:
                    print(f"âš ï¸ Popup selector {selector} failed: {e}")
                    continue
            
            if statistics_element:
                # Scroll to the element to ensure it's visible
                self.driver.execute_script("arguments[0].scrollIntoView(true);", statistics_element)
                #time.sleep(2)
                
                # Generate filename for statistics screenshot
                timestamp = int(time.time())
                filename = f"statistics_info_{timestamp}.png"
                project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                filepath = os.path.join(project_root, "screenshots", filename)
                
                # Take screenshot of the statistics element
                statistics_element.screenshot(filepath)
                
                print(f"âœ… Statistics Info captured: {filename}")
                print(f"ğŸ“ Captured area: {statistics_element.size['width']}x{statistics_element.size['height']}")
                
                return filepath
            else:
                print("âŒ Could not find Statistics Info popup after clicking icon")
                return None
                
        except Exception as e:
            print(f"âŒ Statistics Info capture failed: {e}")
            return None
    
    def extract_statistics_and_calculate_tps(self, statistics_text):
        """
        Extract statistics data from the popup text and calculate TPS
        TPS = Max Trade Success / 60
        """
        try:
            import re
            
            # Split the text into lines and process
            lines = statistics_text.strip().split('\n')
            tps_data = []
            
            print("ğŸ” Parsing statistics data:")
            for line in lines:
                print(f"   ğŸ“ Line: {line}")
            
            # Look for data patterns - the format appears to be:
            # Column Max Min Average Total Count
            # metric_name max_value min_value avg_value total_value count_value
            
            data_started = False
            for i, line in enumerate(lines):
                # Skip header lines until we find actual data
                if 'Column' in line and 'Max' in line and 'Min' in line:
                    print(f"   ğŸ“Š Found header at line {i}: {line}")
                    data_started = True
                    continue
                    
                if data_started and line.strip():
                    # Enhanced parsing for multi-word metrics
                    # Pattern: "Metric Name number.nn number.nn number.nn number.nn number"
                    # Use regex to capture metric name and numbers
                    pattern = r'^(.+?)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+)$'
                    match = re.match(pattern, line.strip())
                    
                    if match:
                        metric_name = match.group(1).strip()
                        max_value = float(match.group(2))
                        min_value = float(match.group(3))
                        avg_value = float(match.group(4))
                        total_value = float(match.group(5))
                        count_value = int(match.group(6))
                        
                        # Calculate TPS: max / 60
                        tps = max_value / 60
                        
                        result = {
                            'metric': metric_name,
                            'max': max_value,
                            'min': min_value,
                            'average': avg_value,
                            'total': total_value,
                            'count': count_value,
                            'tps': tps,
                            'raw_data': line.strip()
                        }
                        tps_data.append(result)
                        
                        print(f"   âœ… Parsed {metric_name}: Max={max_value}, TPS={tps:.2f}")
                    else:
                        print(f"   âš ï¸ Could not parse line pattern: {line}")
            
            # Special handling for "Trade Success" metric for primary TPS calculation
            trade_success_tps = None
            for item in tps_data:
                if 'Trade Success' in item['metric']:
                    trade_success_tps = item['tps']
                    print(f"ğŸ¯ Primary TPS (Trade Success): {trade_success_tps:.2f}")
                    break
            
            return tps_data if tps_data else None
            
        except Exception as e:
            print(f"âŒ TPS calculation failed: {e}")
            return None
    
    def save_tps_data(self, tps_data):
        """Save TPS data to a JSON file with timestamp"""
        try:
            import json
            from datetime import datetime
            
            # Create data structure with timestamp
            timestamp = datetime.now().isoformat()
            data_to_save = {
                'timestamp': timestamp,
                'capture_time': timestamp,
                'tps_calculations': tps_data
            }
            
            # Save to TPS data file
            project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
            tps_file = os.path.join(project_root, "tps_data.json")
            
            # Load existing data if file exists
            existing_data = []
            if os.path.exists(tps_file):
                try:
                    with open(tps_file, 'r') as f:
                        existing_data = json.load(f)
                except:
                    existing_data = []
            
            # Append new data
            existing_data.append(data_to_save)
            
            # Keep only last 100 entries to prevent file from getting too large
            if len(existing_data) > 100:
                existing_data = existing_data[-100:]
            
            # Save updated data
            with open(tps_file, 'w') as f:
                json.dump(existing_data, f, indent=2)
            
            print(f"ğŸ’¾ TPS data saved to: {tps_file}")
            print(f"ğŸ“Š Total TPS records: {len(existing_data)}")
            
        except Exception as e:
            print(f"âŒ Failed to save TPS data: {e}")
    
    def capture_full_interface(self):
        """Capture Trade Trends chart with time range controls"""
        print("ğŸ“¸ Capturing Trade Trends with time range controls...")
        
        #time.sleep(3)  # Wait for interface to load
        
        # Find the popup container with both time controls and chart
        try:
            container_element = self.driver.find_element(By.XPATH, "//div[contains(@class, 'xf-pop-up-container')]")
            
            # Verify it has the components we want
            has_date_inputs = len(container_element.find_elements(By.XPATH, ".//input[@placeholder='Date']")) > 0
            has_trade_trends = len(container_element.find_elements(By.XPATH, ".//span[contains(text(), 'Trade Trends')]")) > 0
            
            if has_date_inputs and has_trade_trends:
                # Generate filename
                timestamp = int(time.time())
                filename = f"trade_trends_with_timerange_{timestamp}.png"
                # Use absolute path to screenshots directory
                project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                filepath = os.path.join(project_root, "screenshots", filename)
                
                # Scroll to element and capture
                self.driver.execute_script("arguments[0].scrollIntoView(true);", container_element)
                #time.sleep(2)
                container_element.screenshot(filepath)
                
                print(f"âœ… Full interface captured: {filename}")
                print(f"ğŸ“ Captured area: {container_element.size['width']}x{container_element.size['height']}")
                
                return filepath
            else:
                print("âš ï¸  Container doesn't have expected components")
                return None
                
        except Exception as e:
            print(f"âŒ Full interface capture failed: {e}")
            return None
    
    def run_automation(self, chart_only=False, statistics_only=False):
        """Execute the complete automation workflow"""
        try:
            print("ğŸ“Š Trade Trends Dashboard Automation")
            print("=" * 50)
            
            # Setup browser
            self.setup_driver()
            
            # Login and setup
            if not self.login_and_setup():
                print("âŒ Login failed")
                return None
            
            print("âœ… Login and setup successful")
            
            # Click Trade Trends
            if not self.click_trade_trends():
                print("âŒ Could not access Trade Trends")
                return None
                
            print("âœ… Trade Trends accessed successfully")
            
            # Capture based on user preference
            if statistics_only:
                screenshot_path = self.capture_statistics_info()
                capture_type = "Statistics Info table"
            elif chart_only:
                screenshot_path = self.capture_chart_only()
                capture_type = "chart only"
            else:
                screenshot_path = self.capture_full_interface()
                capture_type = "full interface with time range"
                
            if screenshot_path:
                print(f"\nğŸ‰ SUCCESS!")
                print(f"ğŸ“¸ Trade Trends {capture_type} captured successfully!")
                print(f"ğŸ“ File: {screenshot_path}")
                return screenshot_path
            else:
                print(f"âŒ {capture_type} capture failed")
                return None
                
        except Exception as e:
            print(f"âŒ Automation failed: {e}")
            return None
        
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Close browser and cleanup"""
        if self.driver:
            self.driver.quit()
            print("ğŸ”„ Browser closed")

def main():
    """Main execution function with command line arguments"""
    parser = argparse.ArgumentParser(description='Trade Trends Dashboard Automation')
    parser.add_argument('--chart-only', action='store_true', 
                       help='Capture only the chart (default: full interface)')
    parser.add_argument('--statistics-only', action='store_true',
                       help='Capture only the Statistics Info table')
    parser.add_argument('--tps-report', action='store_true',
                       help='Capture chart + statistics and send TPS report to DingTalk')
    parser.add_argument('--tps-actioncard', action='store_true',
                       help='Send TPS report using ActionCard format (rich visual)')
    parser.add_argument('--chart-actioncard', action='store_true',
                       help='Send only trade trends chart using ActionCard format')
    parser.add_argument('--chart-image', action='store_true',
                       help='Send trade trends chart as actual image via Enterprise API')
    parser.add_argument('--chart-static', action='store_true',
                       help='Send ActionCard with static image URL that displays inline')
    parser.add_argument('--headless', action='store_true', 
                       help='Run browser in background (default: visible)')
    
    args = parser.parse_args()
    
    # Create automation instance
    automation = TradeTrendsAutomation(headless=args.headless)
    
    if args.tps_report:
        # Single browser session: chart + statistics + TPS report
        print("ğŸš€ Starting Complete TPS Reporting...")
        print("=" * 50)
        automation.setup_driver()
        if not automation.login_and_setup():
            print("âŒ Login failed")
            automation.cleanup()
            return
        print("âœ… Login and setup successful")
        if not automation.click_trade_trends():
            print("âŒ Could not access Trade Trends")
            automation.cleanup()
            return
        print("âœ… Trade Trends accessed successfully")
        print("ğŸ“ˆ Capturing Trade Trends chart...")
        chart_result = automation.capture_chart_only()
        if not chart_result:
            print("âŒ Failed to capture trade trends chart")
            automation.cleanup()
            return
        print(f"âœ… Chart captured: {chart_result}")
        print("ğŸ“Š Capturing Statistics Info...")
        stats_result = automation.capture_statistics_info()
        if not stats_result:
            print("âŒ Failed to capture statistics")
            automation.cleanup()
            return
        print(f"âœ… Statistics captured: {stats_result}")
        automation.cleanup()
        # Load TPS data
        print("\nğŸ“ˆ Step 3: Loading TPS data...")
        tps_data = None
        tps_file = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tps_data.json")
        if os.path.exists(tps_file):
            try:
                with open(tps_file, 'r') as f:
                    data = json.load(f)
                if data:
                    tps_data = data[-1]['tps_calculations']
                    print(f"âœ… TPS data loaded: {len(tps_data)} metrics")
            except Exception as e:
                print(f"âš ï¸ Could not load TPS data: {e}")
        # Send to DingTalk
        print("\nğŸ“¤ Step 4: Sending TPS report to DingTalk...")
        try:
            sys.path.append(os.path.dirname(__file__))
            from dingtalk_sender import DingTalkSender
            sender = DingTalkSender()
            success = sender.send_tps_report(chart_result, stats_result, tps_data)
            if success:
                print("ğŸ‰ Complete TPS Report sent to DingTalk successfully!")
            else:
                print("âŒ Failed to send TPS Report to DingTalk")
        except ImportError as e:
            print(f"âŒ Could not import DingTalk sender: {e}")
        except Exception as e:
            print(f"âŒ Error sending to DingTalk: {e}")
        print("ğŸ”„ Automation completed")
        
    elif args.tps_actioncard:
        # ActionCard TPS reporting workflow
        print("ğŸš€ Starting ActionCard TPS Reporting...")
        print("=" * 50)
        
        # Step 1: Capture trade trends chart
        print("ğŸ“ˆ Step 1: Capturing Trade Trends chart...")
        chart_result = automation.run_automation(chart_only=False, statistics_only=False)
        
        if not chart_result:
            print("âŒ Failed to capture trade trends chart")
            return
        
        print(f"âœ… Chart captured: {chart_result}")
        
        # Step 2: Capture statistics and calculate TPS  
        print("\nğŸ“Š Step 2: Capturing Statistics and calculating TPS...")
        stats_result = automation.run_automation(chart_only=False, statistics_only=True)
        
        if not stats_result:
            print("âŒ Failed to capture statistics")
            return
            
        print(f"âœ… Statistics captured: {stats_result}")
        
        # Step 3: Load TPS data
        print("\nğŸ“ˆ Step 3: Loading TPS data...")
        tps_data = None
        tps_file = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tps_data.json")
        
        if os.path.exists(tps_file):
            try:
                with open(tps_file, 'r') as f:
                    data = json.load(f)
                if data:
                    tps_data = data[-1]['tps_calculations']  # Get latest TPS data
                    print(f"âœ… TPS data loaded: {len(tps_data)} metrics")
            except Exception as e:
                print(f"âš ï¸ Could not load TPS data: {e}")
        
        # Step 4: Send ActionCard to DingTalk
        print("\nğŸ“¤ Step 4: Sending ActionCard TPS report to DingTalk...")
        try:
            # Import DingTalk sender
            sys.path.append(os.path.dirname(__file__))
            from dingtalk_sender import DingTalkSender
            
            sender = DingTalkSender()
            success = sender.send_tps_actioncard_report(chart_result, stats_result, tps_data)
            
            if success:
                print("ğŸ‰ ActionCard TPS Report sent to DingTalk successfully!")
            else:
                print("âŒ Failed to send ActionCard TPS Report to DingTalk")
                
        except ImportError as e:
            print(f"âŒ Could not import DingTalk sender: {e}")
        except Exception as e:
            print(f"âŒ Error sending ActionCard to DingTalk: {e}")
        
        print("ğŸ”„ ActionCard automation completed")
        
    elif args.chart_actioncard:
        # Chart-only ActionCard workflow
        print("ğŸš€ Starting Chart-only ActionCard...")
        print("=" * 50)
        
        # Capture trade trends chart
        print("ğŸ“ˆ Capturing Trade Trends chart...")
        chart_result = automation.run_automation(chart_only=False, statistics_only=False)
        
        if not chart_result:
            print("âŒ Failed to capture trade trends chart")
            return
        
        print(f"âœ… Chart captured: {chart_result}")
        
        # Send Chart ActionCard to DingTalk
        print("\nğŸ“¤ Sending Chart ActionCard to DingTalk...")
        try:
            # Import DingTalk sender
            sys.path.append(os.path.dirname(__file__))
            from dingtalk_sender import DingTalkSender
            
            sender = DingTalkSender()
            success = sender.send_chart_actioncard(chart_result)
            
            if success:
                print("ğŸ‰ Chart ActionCard sent to DingTalk successfully!")
            else:
                print("âŒ Failed to send Chart ActionCard to DingTalk")
                
        except ImportError as e:
            print(f"âŒ Could not import DingTalk sender: {e}")
        except Exception as e:
            print(f"âŒ Error sending Chart ActionCard to DingTalk: {e}")
        
        print("ğŸ”„ Chart ActionCard automation completed")
        
    elif args.chart_image:
        # Chart as actual image workflow
        print("ğŸš€ Starting Chart Image Upload...")
        print("=" * 50)
        
        # Capture trade trends chart
        print("ğŸ“ˆ Capturing Trade Trends chart...")
        chart_result = automation.run_automation(chart_only=False, statistics_only=False)
        
        if not chart_result:
            print("âŒ Failed to capture trade trends chart")
            return
        
        print(f"âœ… Chart captured: {chart_result}")
        
        # Send Chart as Image to DingTalk
        print("\nğŸ“¤ Sending Chart as Image to DingTalk...")
        try:
            # Import DingTalk sender
            sys.path.append(os.path.dirname(__file__))
            from dingtalk_sender import DingTalkSender
            
            sender = DingTalkSender()
            success = sender.send_chart_with_image(chart_result)
            
            if success:
                print("ğŸ‰ Chart Image sent to DingTalk successfully!")
            else:
                print("âŒ Failed to send Chart Image to DingTalk")
                
        except ImportError as e:
            print(f"âŒ Could not import DingTalk sender: {e}")
        except Exception as e:
            print(f"âŒ Error sending Chart Image to DingTalk: {e}")
        
        print("ğŸ”„ Chart Image automation completed")
        
    elif args.chart_static:
        # Chart with static image URL in ActionCard workflow
        print("ğŸš€ Starting Chart Static Image ActionCard...")
        print("=" * 50)
        
        # Capture trade trends chart
        print("ğŸ“ˆ Capturing Trade Trends chart...")
        chart_result = automation.run_automation(chart_only=False, statistics_only=False)
        
        if not chart_result:
            print("âŒ Failed to capture trade trends chart")
            return
        
        print(f"âœ… Chart captured: {chart_result}")
        
        # Send Chart with Static Image URL to DingTalk
        print("\nğŸ“¤ Sending ActionCard with Static Image URL to DingTalk...")
        try:
            # Import DingTalk sender
            sys.path.append(os.path.dirname(__file__))
            from dingtalk_sender import DingTalkSender
            
            sender = DingTalkSender()
            success = sender.send_actioncard_with_static_image(chart_result)
            
            if success:
                print("ğŸ‰ ActionCard with Static Image sent to DingTalk successfully!")
            else:
                print("âŒ Failed to send ActionCard with Static Image to DingTalk")
                
        except ImportError as e:
            print(f"âŒ Could not import DingTalk sender: {e}")
        except Exception as e:
            print(f"âŒ Error sending ActionCard with Static Image to DingTalk: {e}")
        
        print("ğŸ”„ Chart Static Image ActionCard automation completed")
        
    else:
        # Original single capture workflow
        result = automation.run_automation(chart_only=args.chart_only, statistics_only=args.statistics_only)
        
        if result:
            if args.statistics_only:
                capture_type = "Statistics Info table"
            elif args.chart_only:
                capture_type = "chart"
            else:
                capture_type = "full interface"
            print(f"\nâœ… Success! Trade Trends {capture_type} captured at: {result}")
        else:
            print("\nâŒ Failed to capture Trade Trends dashboard")

if __name__ == "__main__":
    main()